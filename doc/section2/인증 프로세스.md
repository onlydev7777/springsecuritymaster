# 인증 프로세스

◼︎ 폼 인증

- HTTP 기반의 폼 로그인 인증 메커니즘을 활성화 하는 API
- 기본적으로 스프링 시큐리티가 제공하는 로그인 페이지 사용

◼︎ 폼 인증 흐름
![form-auth-process.png](form-auth-process.png)

◼︎ formLogin() API

- FormLoginConfigurer 설정 클래스를 통해 여러 API 들을 설정할 수 있다.
- 내부적으로 UsernamePasswordAuthenticationFilter가 생성되어 폼 방식의 인증 처리를 담당한다.

```java
public final class HttpSecurity extends
    AbstractConfiguredSecurityBuilder<DefaultSecurityFilterChain, HttpSecurity>
    implements SecurityBuilder<DefaultSecurityFilterChain>, HttpSecurityBuilder<HttpSecurity> {

  public HttpSecurity formLogin(Customizer<FormLoginConfigurer<HttpSecurity>> formLoginCustomizer)
      throws Exception {
    formLoginCustomizer.customize(getOrApply(new FormLoginConfigurer<>())); //FormLoginConfigurer 생성
    return HttpSecurity.this;
  }
}

public final class FormLoginConfigurer<H extends HttpSecurityBuilder<H>> extends
    AbstractAuthenticationFilterConfigurer<H, FormLoginConfigurer<H>, UsernamePasswordAuthenticationFilter> {

  public FormLoginConfigurer() {
    super(new UsernamePasswordAuthenticationFilter(),
        null);  //UsernamePasswordAuthenticationFilter 생성
    usernameParameter("username");
    passwordParameter("password");
  }
}
```

◼︎ UsernamePasswordAuthenticationFilter

- 스프링 시큐리티는 AbstractAuthenticationProcessingFilter 클래스를 사용자의 자격증명을 인증하는 기본 필터로 사용한다.
- UsernamePasswordAuthenticationFilter는 AbstractAuthenticationProcessingFilter를 확장한 클래스로서 사용자 이름과
  비밀번호 인증을 수행한다.
- 인증 프로세스가 초기화 될 때 로그인 페이지와 로그아웃 페이지 생성을 위한 DefaultLoginPageGeneratingFilter와
  DefaultLogoutPageGeneratingFilter가 초기화 된다.

![AbstractAuthenticationProcessingFilter.png](AbstractAuthenticationProcessingFilter.png)

◼︎ 흐름도
![flow-chart.png](flow-chart.png)

```java
public abstract class AbstractAuthenticationProcessingFilter extends GenericFilterBean
    implements ApplicationEventPublisherAware, MessageSourceAware {

  /**
   * process 1) requiresAuthentication 
   *    : RequestMatcher 수행
   *
   * process 2) UsernamePasswordAuthenticationFilter > attemptAuthentication
   *    : UsernamePasswordAuthenticationToken (username + password) 생성
   *      >> 미인증 토큰 생성
   *    : 디버깅 TODO
   *
   * process 3) successfulAuthentication
   *    : 인증 성공하면 SecurityContext 생성
   *    : 세션 스토리지에 save SecurityContext 
   *
   * error-process unsuccessfulAuthentication
   *    : 인증 실패하면 자격증명 Exception 발생
   * @param request
   * @param response
   * @param chain
   * @throws IOException
   * @throws ServletException
   */
  private void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
      throws IOException, ServletException {
    if (!requiresAuthentication(request, response)) {
      chain.doFilter(request, response);
      return;
    }
    try {
      Authentication authenticationResult = attemptAuthentication(request, response);
      if (authenticationResult == null) {
        // return immediately as subclass has indicated that it hasn't completed
        return;
      }
      this.sessionStrategy.onAuthentication(authenticationResult, request, response);
      // Authentication success
      if (this.continueChainBeforeSuccessfulAuthentication) {
        chain.doFilter(request, response);
      }
      successfulAuthentication(request, response, chain, authenticationResult);
    } catch (InternalAuthenticationServiceException failed) {
      this.logger.error("An internal error occurred while trying to authenticate the user.",
          failed);
      unsuccessfulAuthentication(request, response, failed);
    } catch (AuthenticationException ex) {
      // Authentication failed
      unsuccessfulAuthentication(request, response, ex);
    }
  }

  protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response,
      FilterChain chain,
      Authentication authResult) throws IOException, ServletException {
    SecurityContext context = this.securityContextHolderStrategy.createEmptyContext();
    context.setAuthentication(authResult);
    this.securityContextHolderStrategy.setContext(context);
    this.securityContextRepository.saveContext(context, request, response);
    if (this.logger.isDebugEnabled()) {
      this.logger.debug(LogMessage.format("Set SecurityContextHolder to %s", authResult));
    }
    this.rememberMeServices.loginSuccess(request, response, authResult);
    if (this.eventPublisher != null) {
      this.eventPublisher.publishEvent(
          new InteractiveAuthenticationSuccessEvent(authResult, this.getClass()));
    }
    this.successHandler.onAuthenticationSuccess(request, response, authResult);
  }
}

public class UsernamePasswordAuthenticationFilter extends AbstractAuthenticationProcessingFilter {

  @Override
  public Authentication attemptAuthentication(HttpServletRequest request,
      HttpServletResponse response)
      throws AuthenticationException {
    if (this.postOnly && !request.getMethod().equals("POST")) {
      throw new AuthenticationServiceException(
          "Authentication method not supported: " + request.getMethod());
    }
    String username = obtainUsername(request);
    username = (username != null) ? username.trim() : "";
    String password = obtainPassword(request);
    password = (password != null) ? password : "";
    UsernamePasswordAuthenticationToken authRequest = UsernamePasswordAuthenticationToken.unauthenticated(
        username,
        password);
    // Allow subclasses to set the "details" property
    setDetails(request, authRequest);
    return this.getAuthenticationManager().authenticate(authRequest);
  }
}
```