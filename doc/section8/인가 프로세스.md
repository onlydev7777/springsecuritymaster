# 인가 프로세스

- Spring Security 는 요청 기반 권한 부여(Request Based Authorization)와 메서드 기반 권한 부여(Method Based
  Authorization) 를 통해 자원 관리를 제공한다.
- 요청 기반 권한 부여는 클라이언트의 요청에 대한 권한 부여를 모델링 한다.

### HttpSecurity.authorizeHttpRequests()

- authorizeHttpRequests() 을 통해 요청과 권한 규칙이 설정되면 내부적으로 AuthorizationFilter 가 요청에 대한 권한 검사 및 승인 작업을 수행

```java

@EnableWebSecurity
@Configuration
public class SecurityConfig {

  @Bean
  public SecurityFilterChain securityFilterChain(HttpSecurity http,
      HandlerMappingIntrospector introspector) throws Exception {

    http
        .authorizeHttpRequests(authorize -> authorize
            .requestMatchers("/", "/login").permitAll()
            .requestMatchers("/user")
            .hasAuthority("ROLE_USER") // "/user" 엔드포인트에 대해 "USER" 권한을 요구합니다.
            .requestMatchers("/myPage/**")
            .hasRole("USER") // "/mypage" 및 하위 디렉터리에 대해 "USER" 권한을 요구합니다. Ant 패턴 사용.
            .requestMatchers(HttpMethod.POST)
            .hasAuthority("ROLE_WRITE") // POST 메소드를 사용하는 모든 요청에 대해 "write" 권한을 요구합니다.
            .requestMatchers(new AntPathRequestMatcher("/manager/**")).hasAuthority(
                "ROLE_MANAGER") // "/manager" 및 하위 디렉터리에 대해 "MANAGER" 권한을 요구합니다. AntPathRequestMatcher 사용.
            .requestMatchers(new MvcRequestMatcher(introspector, "/admin/payment")).hasAuthority(
                "ROLE_ADMIN") // "/manager" 및 하위 디렉터리에 대해 "MANAGER" 권한을 요구합니다. AntPathRequestMatcher 사용.
            .requestMatchers("/admin/**").hasAnyAuthority("ROLE_ADMIN",
                "ROLE_MANAGER") // "/admin" 및 하위 디렉터리에 대해 "ADMIN" 또는 "MANAGER" 권한 중 하나를 요구합니다.
            .requestMatchers(new RegexRequestMatcher("/resource/[A-Za-z0-9]+", null)).hasAuthority(
                "ROLE_MANAGER") // 정규 표현식을 사용하여 "/resource/[A-Za-z0-9]+" 패턴에 "MANAGER" 권한을 요구합니다.
            .anyRequest().authenticated())// 위에서 정의한 규칙 외의 모든 요청은 인증을 필요로 합니다.
        .formLogin(Customizer.withDefaults())
        .csrf(AbstractHttpConfigurer::disable);

    return http.build();
  }
}
```

##### 주의사항

- 위에서부터 아래로 나열된 순서대로 처리하며 첫번쨰 일치만 적용되고 다음 순서로 넘어가지 않는다.
- "/admin/**" 가 "/admin/db" 요청을 포함하므로 좁은 범위의 경로("/admin/db")를 먼저 정의해야 한다.

### 표현식 및 커스텀 권한 구현

- 표현식을 사용해서 권한 규칙을 설정 하도록 WebExpressionAuthorizationManager 를 제공
- 표현식은 시큐리티가 제공하는 권한 규칙을 사용하거나 사용자가 커스텀하게 구현할 수 있다.

1. 시큐리티 제공 권한 규칙

```
  @Bean
  public SecurityFilterChain securityFilterChain(HttpSecurity http, ApplicationContext context) throws Exception {

      http.authorizeHttpRequests(authorize -> authorize
              .requestMatchers("/user/{name}")
              .access(new WebExpressionAuthorizationManager("#name == authentication.name"))    // 로그인 계정 name 과 요청 url의 name이 일치 해야 한다.

              .requestMatchers("/admin/db")
              .access(new WebExpressionAuthorizationManager("hasAuthority('ROLE_DB') or hasRole('ADMIN')"))

              .anyRequest().authenticated())
              .formLogin(Customizer.withDefaults());

      return http.build();
  }
```

2. **커스텀 권한 규칙**

```
  @Bean
  public SecurityFilterChain securityFilterChain(HttpSecurity http, ApplicationContext context) throws Exception {

      DefaultHttpSecurityExpressionHandler expressionHandler = new DefaultHttpSecurityExpressionHandler();
      expressionHandler.setApplicationContext(context);
      WebExpressionAuthorizationManager expressManager = new WebExpressionAuthorizationManager("@customWebSecurity.check(authentication, request)");  // 사용자 커스텀 권한 체크 빈 매서드를 파라미터로 넘긴다.   
      expressManager.setExpressionHandler(expressionHandler);
      http.authorizeHttpRequests(authorize -> authorize
              .requestMatchers("/custom/**").access(expressManager)
              .anyRequest().authenticated())
              .formLogin(Customizer.withDefaults());

      return http.build();
  }
```

```java

@Component("customWebSecurity")
public class CustomWebSecurity {

  public boolean check(Authentication authentication, HttpServletRequest request) {
    return authentication.isAuthenticated();
  }
}
```

3. 커스텀 Request Matcher

```
  @Bean
  public SecurityFilterChain securityFilterChain(HttpSecurity http, ApplicationContext context) throws Exception {

      http.authorizeHttpRequests(authorize -> authorize
              .requestMatchers(new CustomRequestMatcher("/admin")).hasAuthority("ROLE_ADMIN")
              .anyRequest().authenticated())
              .formLogin(Customizer.withDefaults());

      return http.build();
  }
```

```java
public class CustomRequestMatcher implements RequestMatcher {

  private final String urlPattern;

  public CustomRequestMatcher(String urlPattern) {
    this.urlPattern = urlPattern;
  }

  @Override
  public boolean matches(HttpServletRequest request) {
    String requestURI = request.getRequestURI();
    return requestURI.startsWith(urlPattern);
  }
}
```

### HttpSecurity.securityMatcher()

- securityMatcher 메서드는 특정 패턴에 해당하는 요청에만 보안 규칙을 적용하며 중복해서 정의할 경우 마지막에 설정한 것으로 대체 된다.
- 패턴설정
  ![securityMatcher-패턴설정.png](securityMatcher-패턴설정.png)


- 다중패턴설정
  ![securityMatcher-다중패턴설정.png](securityMatcher-다중패턴설정.png)

```java

@EnableWebSecurity
@Configuration
public class SecurityConfig {

  @Bean
  public SecurityFilterChain securityFilterChain(HttpSecurity http, ApplicationContext context)
      throws Exception {

    http
        .authorizeHttpRequests(authorize -> authorize
            .anyRequest().authenticated())
        .formLogin(Customizer.withDefaults());

    return http.build();
  }

  @Bean
  @Order(1)
  public SecurityFilterChain securityFilterChain2(HttpSecurity http) throws Exception {

    http
        .securityMatchers((matchers) -> matchers.requestMatchers("/api/**",
            "/oauth/**"))   // 1순위 Bean 으로 해당 경로의 request는 permitAll 
        .authorizeHttpRequests(authorize -> authorize
            .anyRequest().permitAll());

    return http.build();
  }
}
```